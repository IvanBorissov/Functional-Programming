#lang racket
(require math/number-theory)

;-------------------------------------------------
;Task 1
;
;Да се дефинира функция (primes-prod x), която за дадено неотрицателно цяло
;число x връща произведението на простите числа, по-малки или равни на √x. Да се
;реализира линеен итеративен процес.

(define (primes-prod n)
  (define sqrt (integer-sqrt n))
  (define (helper x answer)
    (cond [(> x sqrt) answer]
          [(prime? x) (helper (+ x 1) (* answer x))]
          [else (helper (+ x 1) answer)]))
    (helper 2 1))

(primes-prod 12) ; → 6
(primes-prod 49) ; → 210
(primes-prod 1200) ; → 200560490130

;-------------------------------------------------

;-------------------------------------------------
;Task 2
;Да се дефинира функция (shuffle-merge xs ys), която приема два списъка и
;обединява техните елементи в списък, вземайки елементи последователно от двата
;списъка. Ако някой от списъците се изчерпа, всички следващи елементи трябва да
;бъдат взети от другия.

(define (shuffle-merge xs ys)
  (define (helper xs ys answer which?)
    (cond [(empty? xs) (flatten(cons answer ys))]
          [(empty? ys) (flatten(cons answer xs))]
          [(= (remainder which? 2) 1) (helper (rest xs) ys (cons answer (first xs)) (+ which? 1))]
          [else (helper xs (rest ys) (cons answer (first ys)) (+ which? 1) )]))
  (helper xs ys '() 1))

(shuffle-merge '(1) '()) ; → '(1)
(shuffle-merge '(3 4 5) '(2)) ; → '(3 2 4 5)
(shuffle-merge '(3 4 5) '(9 2)) ; → '(3 9 4 2 5)
(shuffle-merge '(3 2 8) '(5 6 1 9 11)) ; → '(3 5 2 6 8 1 9 11)

;-------------------------------------------------

;-------------------------------------------------
;Task 3
;Да се дефинира функция (g-l-sum limit), която приема естествено число limit и
;връща точкова двойка от две естествени числа x и y – такива, че GCD(x, y) + LCM(x,
;y) = limit, където GCD(x, y) е най-голямото цяло число, което дели x и y, а LCM(x,
;y) е най-малкото цяло число, което се дели едновременно от x и от y.
;Приемете, че решение винаги съществува. Ако има няколко такива x и y, функцията
;може да върне произволна комбинация.

(define (g-l-sum limit)
  (define (helper x y)
    (cond [(> y limit) (helper (+ x 1) y)]
          [(= limit (+ (gcd x y) (lcm x y))) (cons x y)]
          [else (helper x (+ y 1))]))
  (helper 1 1))

(g-l-sum 2) ; → '(1 . 1)
(g-l-sum 14) ; → '(6 . 4)
;при това пълно изчерпване винаги ще намерим точковата двойка '(1 . (limit - 1))
;защото обикаляме всички двойки числа от 1 1 до limit, но спрямо уравнението първото валидно решение винаги ще е '(1 . (limit - 1))

(define (g-l-sum2 limit)
  (define (helper x y answer)
    (cond [(and (> x limit) (> y limit)) (cons (cons 1 (- limit 1)) (reverse answer))]
          [(> y limit) (helper (+ x 1) 2 answer)]
          [(= limit (+ (gcd x y) (lcm x y))) (helper x (+ y 1) (cons (cons x y) answer))]
          [else (helper x (+ y 1) answer)]))
  (helper 2 2 '()))

(g-l-sum2 2) ; → '(1 . 1)
(g-l-sum2 14) ; → '(6 . 4)
(g-l-sum2 15)
(g-l-sum2 3162)
;тук слагаме случая с '(1 . (limit - 1)) като граничен случай, защото то винаги е отговор и строим списък с всички възможни точкови двойки, които са отговор на уравнението

;-------------------------------------------------

;-------------------------------------------------
;Task 4
;Разглеждаме матрица 5 × 5, състояща се от 24 нули и една единица. Индексираме
;редовете на матрицата с числа от 1 до 5 отгоре надолу. Индексираме колоните на
;матрицата с числа от 1 до 5 отляво надясно. Един ход е прилагането на само една от
;следните трансформации към матрицата:
;- Размяна на два съседни реда на матрицата, т.е. редове с индекси i и i + 1
;(1 ≤ i < 5).
;- Размяна на две съседни колони на матрицата, т.е. колони с индекси j и j + 1
;(1 ≤ j < 5).
;Матрицата е красива, ако единствената единица се намира в средата ѝ (в клетката,
;която е на пресечната точка на третия ред и третата колона).
;Да се дефинира функцията (steps-bm xss), която приема матрицата xss от
;гореописания вид, представена като списък от списъци. Функцията трябва да връща
;минималния брой ходове, необходими, за да се направи матрицата красива.

(define (mandist a b)
  (+ (abs (- (car a) (car b))) (abs (- (cdr a) (cdr b)))))

(define (steps-bm xss)
  (define (helper i matrix)
    (define row (car matrix))
    (cond [(member 1 row) (mandist (cons 3 3) (cons i (+ 1 (- 5 (length (member 1 row))))))]
          [else (helper (+ i 1) (rest matrix))]))
  (helper 1 xss))


(steps-bm '((0 0 0 0 0)
 (0 0 0 0 1)
 (0 0 0 0 0)
 (0 0 0 0 0)
 (0 0 0 0 0)) ) ; → 3

(steps-bm '((0 0 0 0 0)
 (0 0 0 0 0)
 (0 1 0 0 0)
 (0 0 0 0 0)
 (0 0 0 0 0)) ) ; → 1

(steps-bm '((0 0 0 0 0)
 (0 0 0 0 0)
 (0 0 1 0 0)
 (0 0 0 0 0)
 (0 0 0 0 0)) ) ; → 0

(steps-bm '((0 0 0 0 0)
 (0 0 0 0 0)
 (0 0 0 0 0)
 (0 0 0 0 0)
 (0 0 0 0 1)) ) ; → 4
(steps-bm '
((0 0 0 0 0)
 (0 1 0 0 0)
 (0 0 0 0 0)
 (0 0 0 0 0)
 (0 0 0 0 0)) ) ; → 2

;-------------------------------------------------
